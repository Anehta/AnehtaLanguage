// ═══════════════════════════════════════════════════════════
//  AnehtaLanguage timer {} 语法糖演示
// ═══════════════════════════════════════════════════════════

func fib(n: int) -> int {
    if (n <= 2) {
        return 1
    }
    return fib(n - 1) + fib(n - 2)
}

func factorial(n: int) -> int {
    var result = 1
    for (var i = 2; i <= n; i = i + 1) {
        result = result * i
    }
    return result
}

func is_prime(n: int) -> int {
    if (n <= 1) {
        return 0
    }
    if (n <= 3) {
        return 1
    }
    if (n % 2 == 0) {
        return 0
    }
    for (var i = 3; i * i <= n; i = i + 2) {
        if (n % i == 0) {
            return 0
        }
    }
    return 1
}

func count_primes(limit: int) -> int {
    var count = 0
    for (var i = 2; i <= limit; i = i + 1) {
        if (is_prime(i) == 1) {
            count = count + 1
        }
    }
    return count
}

func collatz_max_steps(limit: int) -> int {
    var best = 0
    for (var n = 1; n <= limit; n = n + 1) {
        var steps = 0
        var x = n
        for (; x != 1; steps = steps + 1) {
            if (x % 2 == 0) {
                x = x / 2
            } else {
                x = x * 3 + 1
            }
        }
        if (steps > best) {
            best = steps
        }
    }
    return best
}

func monte_carlo_pi(samples: int) -> int {
    var inside = 0
    for (var i = 0; i < samples; i = i + 1) {
        var x = 1 ~ 10000
        var y = 1 ~ 10000
        if (x * x + y * y <= 10000 * 10000) {
            inside = inside + 1
        }
    }
    // returns pi * 1000 (e.g. ~3141)
    return inside * 4000 / samples
}

// ─── Benchmark 1: Recursive fib(30) ─────────────────────

timer {
    var result = fib(30)
    print(result)
}

// ─── Benchmark 2: Factorial(20) x 100000 ────────────────

timer {
    var last = 0
    for (var i = 0; i < 100000; i = i + 1) {
        last = factorial(20)
    }
    print(last)
}

// ─── Benchmark 3: Count primes below 10000 ──────────────

timer {
    var primes = count_primes(10000)
    print(primes)
}

// ─── Benchmark 4: Collatz max steps for 1..10000 ────────

timer {
    var best = collatz_max_steps(10000)
    print(best)
}

// ─── Benchmark 5: Monte Carlo pi estimate (100k samples) ─

timer {
    var pi_approx = monte_carlo_pi(100000)
    print(pi_approx)
}

// ─── Benchmark 6: Nested timer blocks ───────────────────

timer {
    timer {
        var x = fib(25)
        print(x)
    }
    timer {
        var y = count_primes(5000)
        print(y)
    }
}
